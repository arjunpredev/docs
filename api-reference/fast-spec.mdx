---
title: "Generate Fast Spec"
api: "POST https://api.pre.dev/fast-spec"
openapi: "POST /fast-spec"
description: "Complete documentation for the Fast Spec endpoint. Generate comprehensive project specifications in 30-40 seconds."
---

# POST /fast-spec

Generate a quick, comprehensive project specification.

## Overview

- **Cost:** 10 credits
- **Use Cases:** MVPs, prototypes, rapid iteration
- **Processing Time:** ~30-40 seconds (sync) or instant return (async)
- **Output:** Complete feature breakdown, architecture, milestones

## Endpoint

```
POST https://api.pre.dev/fast-spec
```

## Headers

**For JSON requests:**
```
Content-Type: application/json
Authorization: Bearer YOUR_API_KEY
```

**For file upload requests:**
```
Content-Type: multipart/form-data
Authorization: Bearer YOUR_API_KEY
```

## Request Body

### Parameters

**For JSON requests:**

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `input` | string | ✅ | Description of what you want to build |
| `currentContext` | string | ❌ | **CRITICAL:** Existing project/codebase context. When provided, generates feature addition spec. When omitted, generates full new project spec with setup, deployment, docs, maintenance |
| `docURLs` | string[] | ❌ | **Optional:** Array of documentation URLs that Architect will reference when generating specifications. Useful for API documentation, design systems, or existing project docs |
| `async` | boolean | ❌ | `false` (default) - wait for completion, or `true` - return immediately with requestId for status polling |

**For file upload requests (multipart/form-data):**

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `file` | File | ❌ | **Optional:** File to be parsed as input (e.g., existing code, documentation, requirements). Can be used alone or combined with `input` text |
| `input` | string | ❌ | **Optional:** Additional text description when using file upload. Can be empty string if using only file |
| `docURLs` | string[] | ❌ | **Optional:** Array of documentation URLs that Architect will reference when generating specifications. Useful for API documentation, design systems, or existing project docs |
| `async` | boolean | ❌ | `false` (default) - wait for completion, or `true` - return immediately with requestId for status polling |

### Understanding `currentContext`

**Omit `currentContext` (New Project):**
```json
{
  "input": "Build a task management SaaS"
}
```
**Generates:** Complete new project including:
- Initial setup and scaffolding
- Deployment configuration
- Documentation structure
- Support and maintenance guidelines
- Infrastructure setup
- CI/CD pipelines
- Monitoring and logging

**Provide `currentContext` (Feature Addition):**
```json
{
  "input": "Add real-time notifications and activity feed",
  "currentContext": "Existing Next.js task management app with Supabase, has auth, task CRUD, team features"
}
```
**Generates:** Incremental feature spec including:
- New features only (respects existing architecture)
- Integration points with current codebase
- Migration considerations
- No redundant setup/deployment (already exists)

### Example: New Project

```json
{
  "input": "Build a SaaS project management tool with team collaboration, real-time updates, task tracking, and time logging. Include user authentication and role-based permissions.",
}
```

### Example: Feature Addition

```json
{
  "input": "Add a calendar view and Gantt chart visualization to the existing project management tool",
  "currentContext": "We have a task management system with list and board views, user auth, and basic team features",
}
```

### Example: Async Request

```json
{
  "input": "Build a comprehensive e-commerce platform with inventory management",
  "async": true
}
```

### Example: With Documentation URLs

```json
{
  "input": "Build a customer support ticketing system with priority levels and file attachments",
  "docURLs": [
    "https://docs.pre.dev",
    "https://docs.stripe.com"
  ]
}
```

### Example: With File Upload

```javascript
// Prepare file upload
const formData = new FormData();
formData.append('file', fileInput.files[0]); // fileInput is your HTML file input
formData.append('input', '');
formData.append('docURLs', JSON.stringify(["https://docs.pre.dev"]));

const response = await fetch('http://localhost:3001/fast-spec', {
  method: 'POST',
  headers: {
    'Authorization': 'Bearer YOUR_API_KEY'
  },
  body: formData
});
```

### Example: File Upload with Additional Context

```javascript
// Upload a requirements document and add context
const formData = new FormData();
formData.append('file', requirementsFile); // PDF or text file with requirements
formData.append('input', 'Please focus on the authentication and user management features from the uploaded requirements document');
formData.append('docURLs', JSON.stringify(["https://docs.pre.dev/auth"]));
```

## Response

### Success Response (Sync Mode)

```json
{
  "endpoint": "fast_spec",
  "input": "Build a SaaS project management tool with team collaboration...",
  "status": "completed",
  "success": true,
  "humanSpecUrl": "https://api.pre.dev/s/a6hFJRV6",
  "codingAgentSpecUrl": "https://api.pre.dev/s/a6hFJRV7",
  "executionTime": 38500,
  "predevUrl": "https://pre.dev/projects/abc123",
  "lovableUrl": "https://lovable.dev/?autosubmit=true#prompt=First%20download%20https%3A%2F%2Fapi.pre.dev%2Fs%2Fa6hFJRV6%2C%20then%20save%20it%20to%20a%20file%20called%20%22spec.md%22%20and%20then%20parse%20it%20and%20implement%20it%20step%20by%20step",
  "cursorUrl": "cursor://anysphere.cursor-deeplink/prompt?text=First+download+https%3A%2F%2Fapi.pre.dev%2Fs%2Fa6hFJRV6%2C+then+save+it+to+a+file+called+%22spec.md%22+and+then+parse+it+and+implement+it+step+by+step",
  "v0Url": "https://v0.dev/chat?q=First%20download%20https%3A%2F%2Fapi.pre.dev%2Fs%2Fa6hFJRV6%2C%20then%20save%20it%20to%20a%20file%20called%20%22spec.md%22%20and%20then%20parse%20it%20and%20implement%20it%20step%20by%20step",
  "boltUrl": "https://bolt.new?prompt=First%20download%20https%3A%2F%2Fapi.pre.dev%2Fs%2Fa6hFJRV6%2C%20then%20save%20it%20to%20a%20file%20called%20%22spec.md%22%20and%20then%20parse%20it%20and%20implement%20it%20step%20by%20step",
  "zippedDocsUrls": [
    {
      "platform": "stripe.com",
      "masterZipShortUrl": "https://api.pre.dev/s/xyz789"
    },
    {
      "platform": "docs.github.com",
      "masterZipShortUrl": "https://api.pre.dev/s/abc456"
    }
  ]
}
```

| Field | Type | Description |
|-------|------|-------------|
| `endpoint` | string | Endpoint used: `"fast_spec"` or `"deep_spec"` |
| `input` | string | Original input text provided |
| `status` | string | Completion status: `"completed"` when successful |
| `success` | boolean | Whether the request succeeded |
| `humanSpecUrl` | string | URL where the human-readable spec is hosted (downloadable markdown) |
| `totalHumanHours` | number | Estimated total hours for a human to implement the spec |
| `codingAgentSpecUrl` | string | URL where the coding agent spec format is hosted (downloadable markdown) |
| `executionTime` | number | Processing time in milliseconds |
| `predevUrl` | string | pre.dev project URL where you can view and edit the spec |
| `lovableUrl` | string | Deep link to Lovable.dev with auto-submit prompt to implement the spec |
| `cursorUrl` | string | Deep link to Cursor with prompt to download and implement the spec |
| `v0Url` | string | Deep link to Vercel v0 with prompt to implement the spec |
| `boltUrl` | string | Deep link to Bolt.new with prompt to implement the spec |
| `zippedDocsUrls` | array | **New:** Array of scraped documentation archives. Each object contains `platform` (hostname from the doc URL), `masterZipShortUrl` (download link to the ZIP archive), and optional `masterMarkdownShortUrl` (consolidated markdown). Empty array if no `docURLs` provided or scraping fails |

### Success Response (Async Mode)

**Immediate response when `async: true`:**
```json
{
  "specId": "507f1f77bcf86cd799439011",
  "status": "pending"
}
```

| Field | Type | Description |
|-------|------|-------------|
| `specId` | string | Unique ID to poll for status (use with `/api/spec-status/:specId`) |
| `status` | string | Initial status: `"pending"` |

**Poll `/api/spec-status/:specId` to check progress.**

### Async Status Flow

1. **Pending** → Initial queue state
2. **Processing** → Actively generating spec
3. **Completed** → Success, output available
4. **Failed** → Error occurred

**Typical processing times:**
- Fast Spec: 30-40 seconds
- Deep Spec: 2-3 minutes

Poll every 10-15 seconds for best UX.

## Output Structure: Milestones → Stories

Fast Spec follows a **two-level hierarchy** optimized for rapid development:

```markdown
### - [ ] **Milestone 1**: User authentication and profile management

- [ ] **User Registration** - (M): As a: new user, I want to: register an account with email and password, So that: I can access the platform
  - **Acceptance Criteria:**
    - [ ] User can register with valid email and password
    - [ ] Email verification sent upon registration
    - [ ] Duplicate emails handled gracefully
    - [ ] Password strength requirements enforced

- [ ] **User Login** - (S): As a: registered user, I want to: log in securely, So that: I can access my account
  - **Acceptance Criteria:**
    - [ ] User can log in with correct credentials
    - [ ] Invalid credentials rejected with clear message
    - [ ] Session persists across browser tabs
    - [ ] Password reset option available

- [ ] **User Profile** - (M): As a: registered user, I want to: manage my profile, So that: I can update my information
  - **Acceptance Criteria:**
    - [ ] User can view and edit profile details
    - [ ] Shipping addresses can be saved
    - [ ] Password can be changed with re-authentication
    - [ ] Account can be deactivated
```

**Key Characteristics:**
- ✅ High-level milestones group related features
- ✅ User stories with acceptance criteria
- ✅ Complexity estimates (XS, S, M, L, XL)
- ❌ No granular implementation subtasks


## Code Examples

### cURL - Complete Flow

**Synchronous Request:**
```bash
curl -X POST https://api.pre.dev/fast-spec \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -d '{
    "input": "Build a real-time collaborative whiteboard with drawing tools, shapes, text, and team presence indicators"
  }'
```

**Asynchronous Request with Polling:**
```bash
# Step 1: Start async processing
RESPONSE=$(curl -X POST https://api.pre.dev/fast-spec \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -d '{
    "input": "Build a CRM with contact management, deal pipeline, and email integration",
    "async": true
  }')

SPEC_ID=$(echo $RESPONSE | jq -r '.specId')

# Step 2: Poll for status
while true; do
  STATUS=$(curl https://api.pre.dev/spec-status/$SPEC_ID \
    -H "Authorization: Bearer YOUR_API_KEY")

  STATE=$(echo $STATUS | jq -r '.status')

  if [ "$STATE" = "completed" ]; then
    echo "Spec ready!"
    echo $STATUS | jq -r '.codingAgentSpecUrl'
    break
  elif [ "$STATE" = "failed" ]; then
    echo "Processing failed"
    echo $STATUS | jq -r '.errorMessage'
    break
  fi

  echo "Status: $STATE - $(echo $STATUS | jq -r '.progress')"
  sleep 10
done
```

### Python - Complete Implementation

```python
import requests
import time
from typing import Dict, Any

class ArchitectAPI:
    def __init__(self, api_key: str):
        self.api_key = api_key
        self.base_url = "https://api.pre.dev"

    def generate_spec(
        self,
        input_text: str,
        current_context: str = None,
        async_mode: bool = False
    ) -> Dict[str, Any]:
        """Generate a fast spec."""
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {self.api_key}"
        }

        payload = {
            "input": input_text,
            "async": async_mode
        }

        if current_context:
            payload["currentContext"] = current_context

        response = requests.post(
            f"{self.base_url}/fast-spec",
            headers=headers,
            json=payload
        )

        response.raise_for_status()
        return response.json()

    def check_status(self, spec_id: str) -> Dict[str, Any]:
        """Check async processing status."""
        headers = {"Authorization": f"Bearer {self.api_key}"}

        response = requests.get(
            f"{self.base_url}/spec-status/{spec_id}",
            headers=headers
        )

        response.raise_for_status()
        return response.json()

    def wait_for_completion(self, spec_id: str, poll_interval: int = 10) -> Dict[str, Any]:
        """Wait for async processing to complete."""
        while True:
            status = self.check_status(spec_id)

            if status["status"] == "completed":
                return status
            elif status["status"] == "failed":
                raise Exception(f"Processing failed: {status.get('errorMessage')}")

            print(f"Status: {status['status']} - {status.get('progress', 'Processing...')}")
            time.sleep(poll_interval)

# Usage
api = ArchitectAPI(api_key="YOUR_API_KEY")

# Synchronous (wait for result)
result = api.generate_spec(
    input_text="Build a fitness tracking app with workout logging, progress charts, and social features",
)
print(f"Spec URL: {result['codingAgentSpecUrl']}")

# Asynchronous (poll for result)
response = api.generate_spec(
    input_text="Add AI meal planning and nutrition tracking to existing fitness app",
    current_context="Existing app has workout logging, user profiles, and basic social features built with React Native and Firebase",
    async_mode=True
)

result = api.wait_for_completion(response["specId"])
print(f"Spec ready: {result['codingAgentSpecUrl']}")
```

### JavaScript/Node.js - Complete Implementation

```javascript
const fetch = require('node-fetch');

class ArchitectAPI {
  constructor(apiKey) {
    this.apiKey = apiKey;
    this.baseUrl = 'https://api.pre.dev';
  }

  async generateSpec({
    input,
    currentContext = null,
    async = false
  }) {
    const headers = {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${this.apiKey}`
    };

    const payload = {
      input,
      async
    };

    if (currentContext) {
      payload.currentContext = currentContext;
    }

    const response = await fetch(`${this.baseUrl}/fast-spec`, {
      method: 'POST',
      headers,
      body: JSON.stringify(payload)
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.message || 'API request failed');
    }

    return response.json();
  }

  async checkStatus(specId) {
    const headers = { 'Authorization': `Bearer ${this.apiKey}` };

    const response = await fetch(
      `${this.baseUrl}/spec-status/${specId}`,
      { headers }
    );

    if (!response.ok) {
      throw new Error('Failed to check status');
    }

    return response.json();
  }

  async waitForCompletion(specId, pollInterval = 10000) {
    while (true) {
      const status = await this.checkStatus(specId);

      if (status.status === 'completed') {
        return status;
      } else if (status.status === 'failed') {
        throw new Error(`Processing failed: ${status.errorMessage}`);
      }

      console.log(`Status: ${status.status} - ${status.progress || 'Processing...'}`);
      await new Promise(resolve => setTimeout(resolve, pollInterval));
    }
  }
}

// Usage Examples

// Synchronous
(async () => {
  const api = new ArchitectAPI('YOUR_API_KEY');

  try {
    const result = await api.generateSpec({
      input: 'Build an e-learning platform with video courses, quizzes, certificates, and student progress tracking'
    });

    console.log('Spec URL:', result.codingAgentSpecUrl);
  } catch (error) {
    console.error('Error:', error.message);
  }
})();

// With Documentation URLs
(async () => {
  const api = new ArchitectAPI('YOUR_API_KEY');

  try {
    const result = await api.generateSpec({
      input: 'Build a customer support ticketing system with priority levels and file attachments',
      docURLs: [
        'https://docs.pre.dev',
        'https://docs.stripe.com'
      ]
    });

    console.log('Spec URL:', result.codingAgentSpecUrl);
  } catch (error) {
    console.error('Error:', error.message);
  }
})();

// With File Upload
(async () => {
  const api = new ArchitectAPI('YOUR_API_KEY');

  try {
    // For file uploads, use multipart/form-data
    const formData = new FormData();
    formData.append('file', fileInput.files[0]);
    formData.append('input', 'Analyze the uploaded requirements document');
    formData.append('docURLs', JSON.stringify(['https://docs.pre.dev']));

    const response = await fetch(`${api.baseUrl}/fast-spec`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${api.apiKey}`
        // Note: Don't set Content-Type for FormData - browser sets it automatically
      },
      body: formData
    });

    const result = await response.json();
    console.log('Spec URL:', result.codingAgentSpecUrl);
  } catch (error) {
    console.error('Error:', error.message);
  }
})();

// Asynchronous with polling
(async () => {
  const api = new ArchitectAPI('YOUR_API_KEY');

  try {
    // Start processing
    const response = await api.generateSpec({
      input: 'Add gamification with points, badges, and leaderboards',
      currentContext: 'Existing e-learning platform with courses and progress tracking',
      async: true
    });

    console.log('Spec ID:', response.specId);

    // Wait for completion
    const result = await api.waitForCompletion(response.specId);
    console.log('Spec ready:', result.codingAgentSpecUrl);
  } catch (error) {
    console.error('Error:', error.message);
  }
})();
```

### TypeScript - Type-Safe Implementation

```typescript
interface SpecRequest {
  input: string;
  currentContext?: string;
  docURLs?: string[];
  async?: boolean;
}

interface FileUploadRequest {
  file?: File;
  input?: string;
  docURLs?: string[];
  async?: boolean;
}

interface SpecResponse {
  codingAgentSpecUrl?: string;
  markdown?: string;
  fileUrl: string;
}

interface AsyncResponse {
  specId: string;
  status: 'pending' | 'processing' | 'completed' | 'failed';
}

interface ZippedDocsUrl {
  platform: string;
  masterZipShortUrl: string;
  masterMarkdownShortUrl?: string;
}

interface StatusResponse {
  _id?: string;
  created?: string;
  endpoint: 'fast_spec' | 'deep_spec';
  input: string;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  success: boolean;
  uploadedFileShortUrl?: string;
  uploadedFileName?: string;
  humanSpecUrl?: string;
  totalHumanHours?: number;
  codingAgentSpecUrl?: string;
  executionTime?: number;
  predevUrl?: string;
  lovableUrl?: string;
  cursorUrl?: string;
  v0Url?: string;
  boltUrl?: string;
  zippedDocsUrls?: ZippedDocsUrl[];
  errorMessage?: string;
  progress?: string;
}

class ArchitectAPI {
  private apiKey: string;
  private baseUrl: string = 'https://api.pre.dev';

  constructor(apiKey: string) {
    this.apiKey = apiKey;
  }

  async generateSpec(request: SpecRequest): Promise<SpecResponse | AsyncResponse> {
    const response = await fetch(`${this.baseUrl}/fast-spec`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.apiKey}`
      },
      body: JSON.stringify(request)
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.message || 'API request failed');
    }

    return response.json();
  }

  async checkStatus(specId: string): Promise<StatusResponse> {
    const response = await fetch(`${this.baseUrl}/spec-status/${specId}`, {
      headers: { 'Authorization': `Bearer ${this.apiKey}` }
    });

    if (!response.ok) {
      throw new Error('Failed to check status');
    }

    return response.json();
  }

  async waitForCompletion(specId: string, pollInterval: number = 10000): Promise<StatusResponse> {
    while (true) {
      const status = await this.checkStatus(specId);

      if (status.status === 'completed') {
        return status;
      } else if (status.status === 'failed') {
        throw new Error(`Processing failed: ${status.errorMessage}`);
      }

      console.log(`${status.status}: ${status.progress || 'Processing...'}`);
      await new Promise(resolve => setTimeout(resolve, pollInterval));
    }
  }
}
```

## What You Get

The generated specification includes:

- ✅ **Executive summary**
- ✅ **Feature breakdown** by category
- ✅ **Technical architecture** recommendations
- ✅ **Implementation milestones** with effort estimates
- ✅ **User stories** and acceptance criteria
- ✅ **Task checklist** with progress tracking
  - Task status legend: `[ ]` → `[→]` → `[✓]` → `[⊘]`
  - Update as your agent completes work
  - Keep both you and AI aligned on progress
- ✅ **Risk analysis** and considerations
- ✅ **Markdown formatted** for direct agent use

## Using Task Tracking

As your agent implements features, actively manage progress:

1. **Mark tasks in progress:** Change `[ ]` to `[→]` when starting
2. **Mark complete:** Change `[→]` to `[✓]` when done
3. **Mark skipped:** Change `[ ]` to `[⊘]` if skipping (with reason)

**Pro Tip:** Don't let your agent skip tasks without questioning why. This keeps implementation comprehensive and on-track.

## Documentation Scraping & Archives

### Overview

When you provide `docURLs` in your request, Architect automatically scrapes the documentation in parallel with spec generation and packages it into downloadable ZIP archives. This feature helps AI agents and developers have context about external APIs, design systems, or frameworks referenced in the spec.

### How It Works

1. **Parallel Processing:** Documentation scraping runs simultaneously with spec generation (not sequentially), so it doesn't slow down your request
2. **Graceful Degradation:** If documentation scraping fails, spec generation still completes successfully
3. **Organized Archives:** Each platform gets its own ZIP with hierarchical folder structure based on the documentation site

### Response Field: `zippedDocsUrls`

```typescript
interface ZippedDocsUrl {
  platform: string;              // Hostname extracted from doc URL (e.g., "stripe.com", "docs.github.com")
  masterZipShortUrl: string;     // Short URL to download the ZIP archive
  masterMarkdownShortUrl?: string; // Optional: consolidated markdown file
}
```

### Example Request with Documentation URLs

```json
{
  "input": "Build a payment processing system with Stripe integration",
  "docURLs": [
    "https://stripe.com/docs/api",
    "https://stripe.com/docs/payments",
    "https://docs.github.com/en/rest"
  ]
}
```

### Example Response with Documentation Archives

```json
{
  "endpoint": "fast_spec",
  "codingAgentSpecUrl": "https://api.pre.dev/s/a6hFJRV6",
  "zippedDocsUrls": [
    {
      "platform": "stripe.com",
      "masterZipShortUrl": "https://api.pre.dev/s/xyz789"
    },
    {
      "platform": "docs.github.com",
      "masterZipShortUrl": "https://api.pre.dev/s/abc456"
    }
  ]
}
```

### ZIP Archive Structure

Each ZIP archive contains:
- Individual markdown files (one per scraped page)
- Hierarchical folder structure mirroring the documentation site
- Organized by documentation site structure

### Supported Domain Formats

The system handles various domain formats:
- `.com`, `.io`, `.org`, `.net`
- `.cloud`, `.dev`, `.ai`
- Country-specific TLDs (`.co.uk`, `.com.au`, etc.)
- Newer TLDs (`.tech`, `.app`, etc.)

### Best Practices for Documentation URLs

**Do:**
- ✅ Provide specific documentation pages relevant to your spec
- ✅ Include API documentation for integrations you're building
- ✅ Reference design system docs for UI consistency
- ✅ Use official documentation sources

**Don't:**
- ❌ Include general marketing pages
- ❌ Link to blog posts instead of official documentation
- ❌ Reference deprecated or outdated documentation
- ❌ Link to non-documentation content

### Viewing Documentation Archives

**Enterprise users** can view and download documentation archives from the API Usage Logs browser:

1. Navigate to [https://pre.dev/enterprise/dashboard?page=api](https://pre.dev/enterprise/dashboard?page=api)
2. Click on any API call to open the details modal
3. View the "Documentation Archives" section
4. Click download links to get the ZIP files

### Error Handling

If documentation scraping fails:
- `zippedDocsUrls` will be an empty array `[]`
- Spec generation continues normally
- No error is thrown (graceful degradation)

If `docURLs` is not provided or is an empty array:
- `zippedDocsUrls` will be an empty array `[]`
- Spec generation proceeds normally

## Best Practices

### Writing Effective Input
- Be specific about core features
- Include business context and constraints
- Mention technical preferences if any

### Managing Your Agent
- Actively interrupt to ensure tasks are checked off
- Question every skipped task
- Verify acceptance criteria before marking complete
- Triple check that tests are written

<Card title="Next: Deep Spec Endpoint" icon="arrow-right" href="/api-reference/deep-spec">
  Generate ultra-detailed specifications for complex projects.
</Card>
